

===== Level crossing and entanglement in a simple  solvable model =====

Add discussion about entanglement and expand model to include 4 x 4 matrix


In order to study the importance of intruder states, we let
our hamiltonian depend linearly on a strength parameter $z$
!bt
\[
       H=H_0+z H_1,
\]
!et
with $z \in [0,1]$, where the limits $z=0$ and $z=1$ represent the 
non-interacting (or unperturbed) and fully interacting system, respectively.
The model is an eigenvalue
problem with only two available states, which we label
$P$ and $Q$. Below we will let 
state $P$ represent the model-space
eigenvalue whereas state $Q$ represents 
the eigenvalue of the excluded space.
The unperturbed solutions to this problem are
!bt
\begin{equation}
       H_0\Phi_P =\epsilon_P\Phi_P
\end{equation}
!et
and
!bt
\begin{equation}
       H_0\Phi_Q =\epsilon_Q\Phi_Q,
\end{equation}
!et
with $\epsilon_P < \epsilon_Q$. We label the off-diagonal
matrix elements $X$, while $X_P=\bra{\Phi_P}H_1\ket{\Phi_P}$ and
$X_Q=\bra{\Phi_Q}H_1\ket{\Phi_Q}$.
The exact eigenvalues problem
!bt
\begin{equation}
\left(\begin{array}{cc}\epsilon_P+z X_P &zX \\
zX &\epsilon_Q+z X_Q \end{array}\right)
\end{equation}
!et
yields
!bt
\begin{eqnarray}
     label{eq:exact}
     E(z)=&\frac{1}{2}\left\{\epsilon_P +\epsilon_Q +zX_P
     +zX_Q \pm \left(
     \epsilon_Q -\epsilon_P +zX_Q-zX_P\right) \right. \\ \nonumber
     & \left. \times\sqrt{1+\frac{4z^2X^2}{\left(
     \epsilon_Q -\epsilon_P +zX_Q-zX_P\right)^2}}
     \right\}.
\end{eqnarray}
!et
An RS expansion for the lowest
eigenstate (defining states $P$ and $Q$ as the model and excluded
spaces, respectively) can be obtained by expanding the lowest
eigenvalue as
!bt
\begin{equation}
      E=\epsilon_P +zX_P+\frac{z^2X^2}{\epsilon_P -\epsilon_Q}+
      \frac{z^3X^2(X_Q-X_P)}{(\epsilon_P -\epsilon_Q)^2}+
      \frac{z^4X^2(X_Q-X_P)^2}{(\epsilon_P -\epsilon_Q)^3}
      -\frac{z^4X^4}{(\epsilon_P -\epsilon_Q)^3}+\dots,
      \label{eq:modela}
\end{equation}
!et
which can be viewed as an effective interaction for state $P$ in which
state $Q$ is taken into account to successive orders of the perturbation.
In this work we choose the parameters $\epsilon_P=0$, $\epsilon_Q=4$,
$X_P=-X_Q=3$ and $X=0.2$. The exact solutions
given by eq.\ (ref{eq:exact})
are shown in fig.\ 1 as functions of the
strength parameter $z$. Pertinent to our choice of
parameters, is that at $z\geq 2/3$,  the lowest eigenstate is
dominated by $\Phi_Q$ while the upper is $\Phi_P$. At $z=1$ the
$\Phi_P$ mixing of the lowest eigenvalue
is $1\%$ while for $z\leq 2/3$
we have a $\Phi_P$ component of more than $90\%$.
The character of the eigenvectors has therefore been interchanged
when passing $z=2/3$. The value of the parameter $X$ represents the
strength of the coupling between the model space and the excluded space.
Thus, this simple Hamiltonian can be used to find the eigenpairs rather easily. The following code computes and plots the eigenvalues. Note that here we permute the eigenvalues as functions of 
!bc pycod
%matplotlib inline

from  matplotlib import pyplot as plt
import numpy as np
dim = 2
#Setting up a tridiagonal matrix and finding eigenvectors and eigenvalues
Hamiltonian = np.zeros((dim,dim))
#number of lambda values
n = 100
lmbd = np.linspace(0.,1.0,n)
e0 = 0.0
e1 = 4.0
X = 0.20
Xp = 3.0
Eigenvalue = np.zeros((dim,n))
for i in range(n): 
    Hamiltonian[0,0] = lmbd[i]*Xp+e0
    Hamiltonian[0,1] = lmbd[i]*X
    Hamiltonian[1,0] = Hamiltonian[0,1]
    Hamiltonian[1,1] = e1+lmbd[i]*(-Xp)
    # diagonalize and obtain eigenvalues, not necessarily sorted
    EigValues, EigVectors = np.linalg.eig(Hamiltonian)
    # sort eigenvectors and eigenvalues
    permute = EigValues.argsort()
    EigValues = EigValues[permute]
    EigVectors = EigVectors[:,permute]
    Eigenvalue[0,i] = EigValues[0]
    Eigenvalue[1,i] = EigValues[1]
plt.plot(lmbd, Eigenvalue[0,:] ,'b-',lmbd, Eigenvalue[1,:],'g-',)
plt.xlabel('$z$')
plt.ylabel('Eigenvalues')
plt.show()
!ec



!bc pycod
%matplotlib inline
from  matplotlib import pyplot as plt
import numpy as np
from scipy.linalg import logm, expm
def log2M(a): # base 2 matrix logarithm
    return logm(a)/np.log(2.0)

dim = 4
Hamiltonian = np.zeros((dim,dim))
#number of lambda values
n = 40
lmbd = np.linspace(0.0,1.0,n)
X = 2.0
Xp = 3.0
# Non-diagonal part as sigma_x tensor product with sigma_x
sx = np.matrix([[0,1],[1,0]])
# Diagonal part as sigma_z tensor product with sigma_z
sz = np.matrix([[1,0],[0,-1]])
sx2 = X*np.kron(sx, sx)
sz2 = Xp*np.kron(sz, sz)
noninteracting = [0.0, 2.5, 6.5, 7.0]
D = np.diag(noninteracting)
Eigenvalue = np.zeros((dim,n))
Entropy = np.zeros(n)

for i in range(n): 
    Hamiltonian = lmbd[i]*(sx2+sz2)+D
    # diagonalize and obtain eigenvalues, not necessarily sorted
    EigValues, EigVectors = np.linalg.eig(Hamiltonian)
    # sort eigenvectors and eigenvalues
    permute = EigValues.argsort()
    EigValues = EigValues[permute]
    EigVectors = EigVectors[:,permute]
    DensityMatrix = np.zeros((dim,dim))
    # Set up density matrix for lowest-lying state
    DensityMatrix = np.outer(EigVectors[:,0],EigVectors[:,0])
    # Project down on substates and find density matrix for subsystem
    d = np.matrix([[1,0],[0,1]])
    v1 = [1.0,0.0]
    proj1 = np.kron(v1,d)
    x1 = proj1 @ DensityMatrix @ proj1.T
    v2 = [0.0,1.0]
    proj2 = np.kron(v2,d)
    x2 = proj2 @ DensityMatrix @ proj2.T
    # Total density matrix for subsystem
    total = x1+x2
    # Entropy
    Entropy[i] = -np.matrix.trace(total @ log2M(total))

    Eigenvalue[0,i] = EigValues[0]
    Eigenvalue[1,i] = EigValues[1]
    Eigenvalue[2,i] = EigValues[2]
    Eigenvalue[3,i] = EigValues[3]
plt.plot(lmbd, Eigenvalue[0,:] ,'b-',lmbd, Eigenvalue[1,:],'g-',)
plt.plot(lmbd, Eigenvalue[2,:] ,'r-',lmbd, Eigenvalue[3,:],'y-',)
plt.xlabel('$\lambda$')
plt.ylabel('Eigenvalues')
plt.show()
plt.plot(lmbd, Entropy)
plt.xlabel('$\lambda$')
plt.ylabel('Entropy')          
plt.show
!ec



